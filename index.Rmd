---
output: html_document
editor_options: 
  chunk_output_type: console
---

# Работа со списками
```{r, message=FALSE}
library(tidyverse)
```

## Что такое списки?
Допустим, вы забыли, что такое список:

```{r}
x <- list(m = "a", n = c(2, 4), o = c("blue", "green", "red"))
x
x$m
x[1]
x[[2]]
x[[2]][2]
```

![](images/6.01_lists.png)

Списки вне R обычно хранят в файлах типа `.json` (по-английски говорят с ударением на первый слог, а вот по-русски прижился вариант с ударением на второй слог: джейсо́н) или `.xml` (мы обсудим только `.json`).

### Превращение JSON в список и обратно
Самое важное, что нужно знать, про `.json`, это то, что там могут хранится:

* пары ключ и значение, заключенные в фигурные скобки `{"ключ":"значение"}`
* упорядочные множества значений, заключенные в квадратные скобки `["значение_1","значение_2",...]`
* некоторые другие типы данных

Чтение и запись `.json` файлов осуществляется при помощи пакета `jsonlite` (не входит в `tidyverse`). Для примера скачаем датасет 30 героев Игры престолов, который  Дж. Р. Р. Мартин достал с ресурса [An API of Ice And Fire](https://anapioficeandfire.com/).

```{r}
got_chars <- jsonlite::read_json("https://raw.githubusercontent.com/agricolamz/2019.12.21_EU_purrr/master/data/got_chars.json")
got_chars[1]
```

Так как `jsonlite` конфликтует в одной функции с `tidyverse`, я не загружаю библиотеку полностью при помощи команды `library(jsonlite)`, а обращаюсь к функциям пакета при помощи выражения `jsonlite::...()`. Пакет `jsonlite` позволяет записывать `.json` файлы при помощи функции `write_json()`:

```{r, eval=FALSE}
jsonlite::write_json(got_chars, "got_chars.json", auto_unbox = TRUE)
# аргумент auto_unbox позволяет сохранять структуру, которую мы видим в R
```

### Просмотр списков в R 

Просмоторщик списков встроен в RStudio. Его можно увидеть, если ткнуть в объект в R или написать команду `View(got_chars)`. Альтернативой может стать функция `jsonedit()` из пакета `listviewer`. Кроме того, что-то можно попробовать выяснить, используя функцию `str()`.

```{r}
str(got_chars[1])
str(got_chars[1], max.level = 2)
str(xml_example)
```

## Пакет `purrr`

В `tidyverse` встроен пакет `purrr`, который среди прочего позволяет работать со списками. Существует [cheat sheet по `purrr`](https://github.com/rstudio/cheatsheets/raw/master/purrr.pdf).

### Функция `map()` и `map...()`
Можно выводить значения в списке на основе имени:

```{r}
got_chars %>% 
  map("name")
```

Можно выводить значения в списке на основе индекса:

```{r}
got_chars %>% 
  map(3)
```

Достаточно полезно знать о функции `unlist()`, которая "убивает" все сложную структуру:

```{r}
got_chars %>% 
  map("name") %>% 
  unlist()
```

Для этого есть и отдельные функции, которые позволяют превратить все в вектор заданного типа:
```{r}
got_chars %>% 
  map_chr("name")
got_chars %>% 
  map_int("id")
got_chars %>% 
  map_lgl("alive")
```

Можно даже создать новый датафрейм:
```{r}
got_chars %>% 
  tibble(name = map_chr(., "name"), # точка обозначает, в какой аргумент должно все пайпиться
         id = map_dbl(., "id"),
         alive = map_lgl(., "alive"))
```

Также существует способ создание датафреймов на основе вектора значений при помощи функции `enframe()`:

```{r}
got_chars %>% 
  map_chr("name") %>% 
  enframe()
```

```{block, type = "rmdtask"}
Скачайте [частотный словарь русского языка [Шаров, Ляшевская 2011]](https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/freq_dict_2011.csv), разбейте столбец `lemma` на буквы при помощи функции `str_split(dict$lemma, "")`, а на основе полученного списка постройте график, на котором изображено, сколько раз встретилась какая буква:
```

```{r, echo=FALSE, cache=TRUE, message=FALSE}
dict <- read_tsv("https://raw.githubusercontent.com/agricolamz/DS_for_DH/master/data/freq_dict_2011.csv")

str_split(dict$lemma, "") %>% 
  unlist() %>%  
  enframe() %>% 
  mutate(value = str_to_lower(value)) %>% 
  filter(str_detect(value, "\\w")) %>% 
  count(value, sort = TRUE) %>% 
  ggplot(aes(fct_reorder(value, n), n, label = n))+
  geom_col()+
  coord_flip()+
  labs(x = "", y = "", caption = "данные из [Ляшевская, Шаров 2011]")
```

Также можно использовать комбинацию функции `map()` и `attr_getter()` чтобы доставать все значения аттрибутов:

```{r}
xml_example$body %>% 
  map(attr_getter("amount"))
```


### Фильтрация списков

Если в списке есть логические выражения, их можно использовать как фильтры. Например, вот так мы оставим только живых героев:
```{r}
got_chars %>% 
  keep("alive") %>% 
  map_chr("name")
```

![](images/6.02_keep.png)

А так -- только мертвых:
```{r}
got_chars %>% 
  discard("alive") %>% 
  map_chr("name")
```

![](images/6.03_discard.png)

Также есть особый фильтр `head_while()` и `tail_while()`, который выделяет единицы (с начала и конца) до первого `FALSE`.

```{r}
got_chars %>% 
  head_while("alive") %>% 
  map_chr("name")

got_chars %>% 
  tail_while("alive") %>% 
  map_chr("name")
```

![](images/6.04_head_while.png)

Если все еще не понятно, взгляните на нашу таблицу:
```{r}
got_chars %>% 
  tibble(name = map_chr(., "name"), # точка обозначает, в какой аргумент должно все пайпиться
         alive = map_lgl(., "alive"))
```

### Операции со списками

Рассмотрим простой пример:

```{r}
my_l <- list(a = 1:3, b = c("a", "b"), c = list("z", c(8, 9)))
my_l
```

Как уже говорилось выше, функция `unlist()` линеаризует списки, превращая их в векторы:

```{r}
my_l %>% 
  unlist()
```

Получился поименнованный вектор, если этого недостаточно, можно уничтожить и имена при помощи функции `unname()`:

```{r}
my_l %>% 
  unlist() %>% 
  unname()
```

Функция `flatten` позволяет уничтожить **лишь один, верхний,**, уровень иерархии:
```{r}
my_l %>% 
  flatten()
```

![](images/6.05_flatten.png)

Как видно из этого примера, первый элемент списка `my_l` превратился в три первых элемента списка, а вот подсписок `c = list("z", c(8, 9))` превратился в элемент `z` и вектор `c(8, 9)`.

Существуют также функции `append()` и `prepend()`, которые позволяют добавлять новый посписок после (или до) старого:

```{r}
list(c(1, 2), c("a", "b", "c")) %>% 
  append(list(new = c(TRUE, FALSE)))
list(c(1, 2), c("a", "b", "c")) %>% 
  prepend(list(new = c(TRUE, FALSE)))
```

Существует также функции `cross()` и `cross2()`, которые позволяют получить уникальные комбинации объектов из двух списков:
```{r}
list(c("a", "b"), 1:3) %>% 
  cross() %>% 
  str()

list("a", "b") %>% 
  cross2(1:3) %>% 
  str()
```

```{block, type = "rmdtask"}
[Скачайте пьесу "Ревизор"](https://raw.githubusercontent.com/dracor-org/rusdracor/master/tei/gogol-revizor.xml), размеченную в [TEI формате](https://tei-c.org/Guidelines/P5/) и постройте представленный ниже график, на котором изображено количество реплик для каждого персонажа. Превратив данные в список, лучше начинать работать с переменной `revizor\$TEI\$text\$body`:
```

```{r cache=TRUE, echo=FALSE}
library(tidyverse)
library(xml2)
revizor <- read_xml("https://raw.githubusercontent.com/dracor-org/rusdracor/master/tei/gogol-revizor.xml")
revizor <- as_list(revizor)

revizor$TEI$text$body %>% 
  flatten() %>% 
  flatten() %>% 
  map(attr_getter("who")) %>% 
  unlist() %>% 
  str_split(" ") %>% 
  unlist() %>% 
  enframe() %>% 
  count(value, sort = TRUE) %>% 
  ggplot(aes(fct_reorder(value, n), n))+
  geom_col()+
  coord_flip()+
  labs(x = "", y = "", caption = "данные из RusDraCor", 
       title = 'Количество реплик в "Ревизоре" Н. Гоголя')
```
